// extension/content.js
// Î¨∏Î≤ï Ïò§Î•ò ÏàòÏ†ïÎêú Ïª®ÌÖêÏ∏† Ïä§ÌÅ¨Î¶ΩÌä∏

class ImprovedPrivacyGuardContent {
    constructor() {
        this.isEnabled = false;
        this.settings = {
            mode: 'medical',
            threshold: 50
        };

        this.lastResult = null;
        this.isProcessing = false;
        this.serverAvailable = false;
        this.settingsUpdateInterval = null;

        // Î™®ÎãàÌÑ∞ÎßÅÌï† ÏöîÏÜåÎì§
        this.textInputs = new Set();
        this.observedElements = new WeakSet();

        console.log('üõ°Ô∏è Í∞úÏÑ†Îêú Privacy Guard Content Script Ï¥àÍ∏∞Ìôî');
        this.init();
    }

    async init() {
        try {
            // ÏÑ§Ï†ï Î°úÎìú Î∞è ÏÉÅÌÉú ÎèôÍ∏∞Ìôî
            await this.loadAndSyncSettings();

            // ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏
            await this.checkServerAvailability();

            // DOM Í∞êÏãú ÏãúÏûë
            this.startDOMObserver();

            // Î©îÏãúÏßÄ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
            this.setupMessageListeners();

            // Ïã§ÏãúÍ∞Ñ ÏÑ§Ï†ï ÎèôÍ∏∞Ìôî ÏãúÏûë
            this.startSettingsSync();

            // Ï£ºÍ∏∞Ï†Å ÏÑúÎ≤Ñ Ï≤¥ÌÅ¨
            this.startPeriodicServerCheck();

            console.log(`üõ°Ô∏è Privacy Guard Ï§ÄÎπÑ ÏôÑÎ£å (ÌôúÏÑ±: ${this.isEnabled}, ÏÑúÎ≤Ñ: ${this.serverAvailable})`);

            // demo-pageÏóê ÏÉÅÌÉú ÏïåÎ¶º
            this.notifyDemoPage();
        } catch (error) {
            console.error('‚ùå Privacy Guard Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
        }
    }

    /**
     * ÏÑ§Ï†ï Î°úÎìú Î∞è ÎèôÍ∏∞Ìôî
     */
    async loadAndSyncSettings() {
        try {
            const result = await chrome.storage.sync.get(['privacyGuardSettings']);
            if (result.privacyGuardSettings) {
                const settings = result.privacyGuardSettings;
                this.isEnabled = settings.enabled || false;
                this.settings = { ...this.settings, ...settings };
                console.log('‚úÖ ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å:', this.settings);
            } else {
                // Í∏∞Î≥∏ ÏÑ§Ï†ï Ï†ÄÏû•
                await this.saveDefaultSettings();
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è ÏÑ§Ï†ï Î°úÎìú Ïã§Ìå®:', error);
        }
    }

    /**
     * Í∏∞Î≥∏ ÏÑ§Ï†ï Ï†ÄÏû•
     */
    async saveDefaultSettings() {
        try {
            const defaultSettings = {
                enabled: false,
                mode: 'medical',
                threshold: 50
            };

            await chrome.storage.sync.set({ privacyGuardSettings: defaultSettings });
            this.settings = defaultSettings;
            console.log('üìù Í∏∞Î≥∏ ÏÑ§Ï†ï Ï†ÄÏû• ÏôÑÎ£å');
        } catch (error) {
            console.warn('‚ö†Ô∏è Í∏∞Î≥∏ ÏÑ§Ï†ï Ï†ÄÏû• Ïã§Ìå®:', error);
        }
    }

    /**
     * Ïã§ÏãúÍ∞Ñ ÏÑ§Ï†ï ÎèôÍ∏∞Ìôî
     */
    startSettingsSync() {
        // Ïä§ÌÜ†Î¶¨ÏßÄ Î≥ÄÍ≤Ω Í∞êÏßÄ
        if (chrome.storage && chrome.storage.onChanged) {
            chrome.storage.onChanged.addListener((changes, namespace) => {
                if (namespace === 'sync' && changes.privacyGuardSettings) {
                    this.onSettingsChanged(changes.privacyGuardSettings.newValue);
                }
            });
        }

        // Ï£ºÍ∏∞Ï†Å ÏÑ§Ï†ï ÌôïÏù∏ (5Ï¥àÎßàÎã§)
        this.settingsUpdateInterval = setInterval(async () => {
            try {
                const result = await chrome.storage.sync.get(['privacyGuardSettings']);
                const storedSettings = result.privacyGuardSettings;

                if (storedSettings && storedSettings.enabled !== this.isEnabled) {
                    this.onSettingsChanged(storedSettings);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Ï£ºÍ∏∞Ï†Å ÏÑ§Ï†ï ÌôïÏù∏ Ïã§Ìå®:', error);
            }
        }, 5000);
    }

    /**
     * ÏÑ§Ï†ï Î≥ÄÍ≤Ω Ï≤òÎ¶¨
     */
    onSettingsChanged(newSettings) {
        if (!newSettings) return;

        const wasEnabled = this.isEnabled;
        this.isEnabled = newSettings.enabled || false;
        this.settings = { ...this.settings, ...newSettings };

        console.log(`üîÑ ÏÑ§Ï†ï Î≥ÄÍ≤Ω Í∞êÏßÄ: ${this.isEnabled ? 'ÌôúÏÑ±Ìôî' : 'ÎπÑÌôúÏÑ±Ìôî'}`);

        // ÏÉÅÌÉú Î≥ÄÍ≤ΩÏóê Îî∞Î•∏ Ï≤òÎ¶¨
        if (wasEnabled !== this.isEnabled) {
            if (!this.isEnabled) {
                this.hideAllWarnings();
            }

            // demo-pageÏóê ÏÉÅÌÉú Î≥ÄÍ≤Ω ÏïåÎ¶º
            this.notifyDemoPage();
        }
    }

    /**
     * demo-pageÏóê ÏÉÅÌÉú ÏïåÎ¶º
     */
    notifyDemoPage() {
        try {
            // demo-pageÍ∞Ä ÌòÑÏû¨ ÌéòÏù¥ÏßÄÏù∏ÏßÄ ÌôïÏù∏
            if (window.location.pathname.includes('demo-page.html') ||
                document.title.includes('Privacy Guard LLM - Ïã§ÏãúÍ∞Ñ ÏãúÏó∞')) {

                window.postMessage({
                    source: 'privacy-guard-extension',
                    action: 'statusUpdate',
                    enabled: this.isEnabled,
                    settings: this.settings
                }, '*');
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è demo-page ÏïåÎ¶º Ïã§Ìå®:', error);
        }
    }

    /**
     * ÏÑúÎ≤Ñ Í∞ÄÏö©ÏÑ± Ï≤¥ÌÅ¨
     */
    async checkServerAvailability() {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 2000);

            const response = await fetch('http://localhost:8000/health', {
                method: 'GET',
                signal: controller.signal,
                headers: { 'Accept': 'application/json' }
            });

            clearTimeout(timeoutId);
            this.serverAvailable = response.ok;

            if (this.serverAvailable) {
                console.log('‚úÖ ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÑ±Í≥µ');
            }

        } catch (error) {
            this.serverAvailable = false;
            console.log('‚ö†Ô∏è ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïã§Ìå® - Î°úÏª¨ Î™®ÎìúÎ°ú ÎèôÏûë');
        }
    }

    /**
     * DOM Í¥ÄÏ∞∞Ïûê ÏãúÏûë
     */
    startDOMObserver() {
        try {
            // Í∏∞Ï°¥ ÏûÖÎ†• ÏöîÏÜåÎì§ Ïä§Ï∫î
            this.scanForTextInputs();

            // MutationObserverÎ°ú ÎèôÏ†Å ÏöîÏÜå Í∞êÏßÄ
            this.observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            this.scanElementForInputs(node);
                        }
                    });
                });
            });

            this.observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        } catch (error) {
            console.warn('‚ö†Ô∏è DOM Í¥ÄÏ∞∞Ïûê ÏãúÏûë Ïã§Ìå®:', error);
        }
    }

    /**
     * ÌÖçÏä§Ìä∏ ÏûÖÎ†• ÏöîÏÜå Ïä§Ï∫î
     */
    scanForTextInputs() {
        const selectors = [
            'textarea',
            'input[type="text"]',
            'input[type="search"]',
            '[contenteditable="true"]',
            '[role="textbox"]'
        ];

        selectors.forEach(selector => {
            try {
                document.querySelectorAll(selector).forEach(element => {
                    this.addInputListener(element);
                });
            } catch (error) {
                console.warn(`‚ö†Ô∏è ÏÑ†ÌÉùÏûê ${selector} Ïä§Ï∫î Ïã§Ìå®:`, error);
            }
        });
    }

    /**
     * ÌäπÏ†ï ÏöîÏÜåÏóêÏÑú ÏûÖÎ†• ÏöîÏÜå Ïä§Ï∫î
     */
    scanElementForInputs(element) {
        try {
            if (this.isTextInput(element)) {
                this.addInputListener(element);
            }

            // ÌïòÏúÑ ÏöîÏÜåÎì§ÎèÑ Ïä§Ï∫î
            const inputs = element.querySelectorAll('textarea, input[type="text"], input[type="search"], [contenteditable="true"], [role="textbox"]');
            inputs.forEach(input => this.addInputListener(input));
        } catch (error) {
            console.warn('‚ö†Ô∏è ÏöîÏÜå Ïä§Ï∫î Ïã§Ìå®:', error);
        }
    }

    /**
     * ÌÖçÏä§Ìä∏ ÏûÖÎ†• ÏöîÏÜåÏù∏ÏßÄ ÌôïÏù∏
     */
    isTextInput(element) {
        if (!element || !element.tagName) return false;

        const tagName = element.tagName.toLowerCase();

        if (tagName === 'textarea') return true;
        if (tagName === 'input' && ['text', 'search'].includes(element.type)) return true;
        if (element.contentEditable === 'true') return true;
        if (element.getAttribute('role') === 'textbox') return true;

        return false;
    }

    /**
     * ÏûÖÎ†• ÏöîÏÜåÏóê Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
     */
    addInputListener(element) {
        if (this.observedElements.has(element)) return;

        this.observedElements.add(element);
        this.textInputs.add(element);

        // Ïã§ÏãúÍ∞Ñ ÏûÖÎ†• Í∞êÏßÄ
        let inputTimeout;
        const handleInput = () => {
            if (!this.isEnabled) return;

            clearTimeout(inputTimeout);
            inputTimeout = setTimeout(() => {
                this.analyzeInput(element);
            }, 1000); // 1Ï¥à ÎîîÎ∞îÏö¥Ïã±
        };

        // Ï†ÑÏÜ° ÏãúÎèÑ Í∞êÏßÄ
        const handleKeyDown = (e) => {
            if (!this.isEnabled) return;

            // Enter ÌÇ§ (Shift+Enter Ï†úÏô∏) ÎòêÎäî Ctrl+Enter
            if ((e.key === 'Enter' && !e.shiftKey) || (e.key === 'Enter' && e.ctrlKey)) {
                this.handleSendAttempt(element, e);
            }
        };

        element.addEventListener('input', handleInput);
        element.addEventListener('keydown', handleKeyDown);

        // Ï†ïÎ¶¨ Ìï®Ïàò Ï†ÄÏû•
        element._privacyGuardCleanup = () => {
            element.removeEventListener('input', handleInput);
            element.removeEventListener('keydown', handleKeyDown);
            this.textInputs.delete(element);
            this.observedElements.delete(element);
        };
    }

    /**
     * ÏûÖÎ†• ÎÇ¥Ïö© Î∂ÑÏÑù
     */
    async analyzeInput(element) {
        const text = this.getElementText(element);
        if (!text || text.length < 10) return;

        try {
            const result = await this.maskText(text);

            // ÎØºÍ∞êÏ†ïÎ≥¥Í∞Ä Í∞êÏßÄÎêòÎ©¥ ÏãúÍ∞ÅÏ†Å Í≤ΩÍ≥†
            if (result.success && result.stats.totalEntities > 0) {
                this.showInputWarning(element, result);
            } else {
                this.hideInputWarning(element);
            }

            this.lastResult = result;

        } catch (error) {
            console.warn('‚ö†Ô∏è ÏûÖÎ†• Î∂ÑÏÑù Ïò§Î•ò:', error);
        }
    }

    /**
     * Ï†ÑÏÜ° ÏãúÎèÑ Ï≤òÎ¶¨ - Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ
     */
    async handleSendAttempt(element, event) {
        const text = this.getElementText(element);
        if (!text || text.length < 5) return;

        try {
            const result = await this.maskText(text);

            if (result.success && result.stats.totalEntities > 0) {
                const action = await this.showSendWarningDialog(result);

                switch (action) {
                    case 'mask':
                        // ÎßàÏä§ÌÇπÎêú ÌÖçÏä§Ìä∏Î°ú ÍµêÏ≤¥
                        this.setElementText(element, result.maskedText);
                        this.showToast('ÎØºÍ∞êÏ†ïÎ≥¥Í∞Ä ÎßàÏä§ÌÇπÎêòÏóàÏäµÎãàÎã§', 'info');
                        break;

                    case 'block':
                        // Ï†ÑÏÜ° Ï∞®Îã®
                        event.preventDefault();
                        event.stopImmediatePropagation();
                        this.showToast('Ï†ÑÏÜ°Ïù¥ Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§', 'warning');
                        return false;

                    case 'ignore':
                        // Î¨¥ÏãúÌïòÍ≥† Ï†ÑÏÜ°
                        this.showToast('Í≤ΩÍ≥†Î•º Î¨¥ÏãúÌïòÍ≥† Ï†ÑÏÜ°Ìï©ÎãàÎã§', 'info');
                        break;
                }
            }

            this.lastResult = result;

        } catch (error) {
            console.error('‚ùå Ï†ÑÏÜ° Ï≤òÎ¶¨ Ïò§Î•ò:', error);
            this.showToast('Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§', 'error');
        }
    }

    /**
     * ÌÖçÏä§Ìä∏ ÎßàÏä§ÌÇπ
     */
    async maskText(text) {
        try {
            if (this.serverAvailable) {
                return await this.serverMaskText(text);
            } else {
                return this.createFallbackResponse(text);
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è ÎßàÏä§ÌÇπ Ï≤òÎ¶¨ Ïã§Ìå®:', error);
            return this.createFallbackResponse(text);
        }
    }

    /**
     * ÏÑúÎ≤Ñ Í∏∞Î∞ò ÎßàÏä§ÌÇπ
     */
    async serverMaskText(text) {
        const response = await fetch('http://localhost:8000/api/mask', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({
                text: text,
                mode: this.settings.mode,
                threshold: this.settings.threshold
            })
        });

        if (!response.ok) {
            throw new Error(`ÏÑúÎ≤Ñ Ïò§Î•ò: ${response.status}`);
        }

        const result = await response.json();

        if (!result.success) {
            throw new Error(result.error || 'ÏÑúÎ≤Ñ Ï≤òÎ¶¨ Ïã§Ìå®');
        }

        return this.normalizeServerResult(result);
    }

    /**
     * Í∏∞Î≥∏ ÏùëÎãµ ÏÉùÏÑ± (ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïã§Ìå® Ïãú)
     */
    createFallbackResponse(text) {
        return {
            success: false,
            error: 'ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞Ìï† Ïàò ÏóÜÏäµÎãàÎã§',
            originalText: text,
            maskedText: text,
            stats: {
                totalEntities: 0,
                maskedEntities: 0,
                avgRisk: 0,
                processingTime: 0
            },
            maskingLog: [],
            timestamp: new Date().toISOString()
        };
    }

    /**
     * ÏÑúÎ≤Ñ Í≤∞Í≥º Ï†ïÍ∑úÌôî
     */
    normalizeServerResult(serverResult) {
        return {
            success: true,
            originalText: serverResult.original_text,
            maskedText: serverResult.masked_text,
            stats: {
                totalEntities: serverResult.stats.total_entities,
                maskedEntities: serverResult.stats.masked_entities,
                avgRisk: serverResult.stats.avg_risk,
                processingTime: serverResult.stats.processing_time
            },
            maskingLog: serverResult.masking_log || [],
            modelInfo: serverResult.model_info,
            timestamp: new Date().toISOString()
        };
    }

    /**
     * Î©îÏãúÏßÄ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
     */
    setupMessageListeners() {
        try {
            // Chrome ÌôïÏû• ÌîÑÎ°úÍ∑∏Îû® Î©îÏãúÏßÄ
            if (chrome.runtime && chrome.runtime.onMessage) {
                chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
                    this.handleMessage(message, sender, sendResponse);
                    return true; // ÎπÑÎèôÍ∏∞ ÏùëÎãµ
                });
            }

            // demo-pageÏôÄÏùò ÌÜµÏã†
            window.addEventListener('message', (event) => {
                if (event.source !== window || !event.data || event.data.source !== 'privacy-guard-demo') {
                    return;
                }

                if (event.data.action === 'maskText') {
                    this.handleDemoMaskRequest(event.data);
                }
            });
        } catch (error) {
            console.warn('‚ö†Ô∏è Î©îÏãúÏßÄ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï Ïã§Ìå®:', error);
        }
    }

    /**
     * demo-page ÎßàÏä§ÌÇπ ÏöîÏ≤≠ Ï≤òÎ¶¨
     */
    async handleDemoMaskRequest(data) {
        try {
            const result = await this.maskText(data.text);

            window.postMessage({
                source: 'privacy-guard-extension',
                action: 'maskTextResult',
                messageId: data.messageId,
                result: result
            }, '*');
        } catch (error) {
            window.postMessage({
                source: 'privacy-guard-extension',
                action: 'maskTextResult',
                messageId: data.messageId,
                result: { success: false, error: error.message }
            }, '*');
        }
    }

    /**
     * Î©îÏãúÏßÄ Ï≤òÎ¶¨
     */
    async handleMessage(message, sender, sendResponse) {
        try {
            switch (message.action) {
                case 'toggleProtection':
                    await this.handleToggleProtection(message);
                    sendResponse({ success: true });
                    break;

                case 'getLastResult':
                    sendResponse({ success: true, result: this.lastResult });
                    break;

                case 'updateSettings':
                    this.onSettingsChanged(message.settings);
                    sendResponse({ success: true });
                    break;

                case 'getStatus':
                    sendResponse({
                        success: true,
                        enabled: this.isEnabled,
                        settings: this.settings
                    });
                    break;

                default:
                    sendResponse({ success: false, error: 'Ïïå Ïàò ÏóÜÎäî Ïï°ÏÖò' });
            }
        } catch (error) {
            console.error('‚ùå Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ïò§Î•ò:', error);
            sendResponse({ success: false, error: error.message });
        }
    }

    /**
     * Î≥¥Ìò∏ Í∏∞Îä• ÌÜ†Í∏Ä Ï≤òÎ¶¨
     */
    async handleToggleProtection(message) {
        this.isEnabled = message.enabled;

        if (message.settings) {
            this.settings = { ...this.settings, ...message.settings };
        }

        console.log(`üõ°Ô∏è Î≥¥Ìò∏ Í∏∞Îä• ${this.isEnabled ? 'ÌôúÏÑ±Ìôî' : 'ÎπÑÌôúÏÑ±Ìôî'}`);

        // Î™®Îì† Í≤ΩÍ≥† Ïà®ÍπÄ
        if (!this.isEnabled) {
            this.hideAllWarnings();
        }

        // demo-pageÏóê ÏÉÅÌÉú ÏïåÎ¶º
        this.notifyDemoPage();
    }

    /**
     * Ìó¨Ìçº Ìï®ÏàòÎì§
     */
    getElementText(element) {
        try {
            if (element.tagName.toLowerCase() === 'textarea' ||
                (element.tagName.toLowerCase() === 'input' && element.type === 'text')) {
                return element.value;
            } else if (element.contentEditable === 'true') {
                return element.innerText || element.textContent;
            }
            return '';
        } catch (error) {
            console.warn('‚ö†Ô∏è ÏöîÏÜå ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
            return '';
        }
    }

    setElementText(element, text) {
        try {
            if (element.tagName.toLowerCase() === 'textarea' ||
                (element.tagName.toLowerCase() === 'input' && element.type === 'text')) {
                element.value = text;
            } else if (element.contentEditable === 'true') {
                element.innerText = text;
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è ÏöîÏÜå ÌÖçÏä§Ìä∏ ÏÑ§Ï†ï Ïã§Ìå®:', error);
        }
    }

    showInputWarning(element, result) {
        try {
            // Í∞ÑÎã®Ìïú ÏãúÍ∞ÅÏ†Å Í≤ΩÍ≥†
            element.style.borderColor = '#e74c3c';
            element.style.boxShadow = '0 0 0 2px rgba(231, 76, 60, 0.2)';
            element.title = `ÎØºÍ∞êÏ†ïÎ≥¥ ${result.stats.totalEntities}Í∞ú Í∞êÏßÄÎê® (ÏúÑÌóòÎèÑ: ${result.stats.avgRisk}%)`;
        } catch (error) {
            console.warn('‚ö†Ô∏è ÏûÖÎ†• Í≤ΩÍ≥† ÌëúÏãú Ïã§Ìå®:', error);
        }
    }

    hideInputWarning(element) {
        try {
            element.style.borderColor = '';
            element.style.boxShadow = '';
            element.title = '';
        } catch (error) {
            console.warn('‚ö†Ô∏è ÏûÖÎ†• Í≤ΩÍ≥† Ïà®ÍπÄ Ïã§Ìå®:', error);
        }
    }

    hideAllWarnings() {
        this.textInputs.forEach(element => {
            this.hideInputWarning(element);
        });
    }

    /**
     * Ï†ÑÏÜ° Í≤ΩÍ≥† Îã§Ïù¥ÏñºÎ°úÍ∑∏
     */
    async showSendWarningDialog(result) {
        const riskLevel = result.stats.avgRisk;
        const entityCount = result.stats.totalEntities;

        // Í≥†ÏúÑÌóòÏùÄ ÏûêÎèô Ï∞®Îã®
        if (riskLevel >= 90) {
            this.showToast(`Í≥†ÏúÑÌóò Ï†ïÎ≥¥ Í∞êÏßÄ! Ï†ÑÏÜ°Ïù¥ ÏûêÎèô Ï∞®Îã®ÎêòÏóàÏäµÎãàÎã§ (ÏúÑÌóòÎèÑ: ${riskLevel}%)`, 'error');
            return 'block';
        }

        // Ï§ëÏúÑÌóòÏùÄ ÏÇ¨Ïö©Ïûê ÏÑ†ÌÉù
        if (riskLevel >= 60) {
            const message = `ÎØºÍ∞êÏ†ïÎ≥¥ ${entityCount}Í∞úÍ∞Ä Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§ (ÏúÑÌóòÎèÑ: ${riskLevel}%)\n\nÏñ¥ÎñªÍ≤å Ï≤òÎ¶¨ÌïòÏãúÍ≤†ÏäµÎãàÍπå?`;
            const action = confirm(`${message}\n\nÌôïÏù∏: ÎßàÏä§ÌÇπ ÌõÑ Ï†ÑÏÜ°\nÏ∑®ÏÜå: Ï†ÑÏÜ° Ï∞®Îã®`);
            return action ? 'mask' : 'block';
        }

        // Ï†ÄÏúÑÌóòÏùÄ ÏûêÎèô ÎßàÏä§ÌÇπ
        if (riskLevel >= 30) {
            this.showToast(`ÎØºÍ∞êÏ†ïÎ≥¥Í∞Ä ÏûêÎèôÏúºÎ°ú ÎßàÏä§ÌÇπÎêòÏóàÏäµÎãàÎã§`, 'info');
            return 'mask';
        }

        // ÏúÑÌóòÎèÑ ÎÇÆÏùå - ÌÜµÍ≥º
        return 'ignore';
    }

    /**
     * ÌÜ†Ïä§Ìä∏ Î©îÏãúÏßÄ ÌëúÏãú
     */
    showToast(message, type = 'info') {
        try {
            // Í∏∞Ï°¥ ÌÜ†Ïä§Ìä∏ Ï†úÍ±∞
            const existingToast = document.querySelector('.privacy-guard-toast');
            if (existingToast) {
                existingToast.remove();
            }

            const toast = document.createElement('div');
            toast.className = 'privacy-guard-toast';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${this.getToastColor(type)};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                z-index: 999999;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 14px;
                font-weight: 600;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                animation: slideInRight 0.3s ease;
                max-width: 300px;
                line-height: 1.4;
            `;

            // ÏïÑÏù¥ÏΩò Ï∂îÍ∞Ä
            const icon = this.getToastIcon(type);
            toast.innerHTML = `${icon} ${message}`;

            document.body.appendChild(toast);

            // ÏûêÎèô Ï†úÍ±∞
            setTimeout(() => {
                toast.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, 300);
            }, 4000);

            // CSS Ïï†ÎãàÎ©îÏù¥ÏÖò Ï∂îÍ∞Ä (Ìïú Î≤àÎßå)
            if (!document.querySelector('#privacy-guard-animations')) {
                const style = document.createElement('style');
                style.id = 'privacy-guard-animations';
                style.textContent = `
                    @keyframes slideInRight {
                        from { opacity: 0; transform: translateX(100%); }
                        to { opacity: 1; transform: translateX(0); }
                    }
                    @keyframes slideOutRight {
                        from { opacity: 1; transform: translateX(0); }
                        to { opacity: 0; transform: translateX(100%); }
                    }
                `;
                document.head.appendChild(style);
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è ÌÜ†Ïä§Ìä∏ ÌëúÏãú Ïã§Ìå®:', error);
        }
    }

    getToastColor(type) {
        const colors = {
            'info': '#3498db',
            'success': '#2ed573',
            'warning': '#f39c12',
            'error': '#e74c3c'
        };
        return colors[type] || colors.info;
    }

    getToastIcon(type) {
        const icons = {
            'info': 'üõ°Ô∏è',
            'success': '‚úÖ',
            'warning': '‚ö†Ô∏è',
            'error': 'üö´'
        };
        return icons[type] || icons.info;
    }

    /**
     * Ï£ºÍ∏∞Ï†Å ÏÑúÎ≤Ñ Ï≤¥ÌÅ¨
     */
    startPeriodicServerCheck() {
        setInterval(() => {
            this.checkServerAvailability();
        }, 30000); // 30Ï¥àÎßàÎã§
    }

    /**
     * Ï†ïÎ¶¨ Ìï®Ïàò
     */
    cleanup() {
        try {
            // MutationObserver Ï†ïÎ¶¨
            if (this.observer) {
                this.observer.disconnect();
            }

            // ÏÑ§Ï†ï ÎèôÍ∏∞Ìôî Ï†ïÎ¶¨
            if (this.settingsUpdateInterval) {
                clearInterval(this.settingsUpdateInterval);
            }

            // Î™®Îì† ÏûÖÎ†• ÏöîÏÜå Î¶¨Ïä§ÎÑà Ï†ïÎ¶¨
            this.textInputs.forEach(element => {
                if (element._privacyGuardCleanup) {
                    element._privacyGuardCleanup();
                }
            });

            // ÌÜ†Ïä§Ìä∏ Î©îÏãúÏßÄ Ï†ïÎ¶¨
            const toasts = document.querySelectorAll('.privacy-guard-toast');
            toasts.forEach(toast => toast.remove());

            console.log('üõ°Ô∏è Privacy Guard Ï†ïÎ¶¨ ÏôÑÎ£å');
        } catch (error) {
            console.warn('‚ö†Ô∏è Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò:', error);
        }
    }
}

// ÏΩòÌÖêÏ∏† Ïä§ÌÅ¨Î¶ΩÌä∏ Ï¥àÍ∏∞Ìôî
let privacyGuard = null;

// DOM Ï§ÄÎπÑÎêòÎ©¥ Ï¥àÍ∏∞Ìôî
function initPrivacyGuard() {
    try {
        if (!privacyGuard) {
            privacyGuard = new ImprovedPrivacyGuardContent();

            // Ï†ÑÏó≠ÏúºÎ°ú ÎÖ∏Ï∂ú (demo-page Ìò∏ÌôòÏÑ±)
            window.privacyGuardContent = privacyGuard;
        }
    } catch (error) {
        console.error('‚ùå Privacy Guard Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPrivacyGuard);
} else {
    initPrivacyGuard();
}

// ÌéòÏù¥ÏßÄ Ïñ∏Î°úÎìú Ïãú Ï†ïÎ¶¨
window.addEventListener('beforeunload', () => {
    if (privacyGuard) {
        privacyGuard.cleanup();
    }
});

// Ï†ÑÏó≠ ÏóêÎü¨ Ìï∏Îì§Îü¨
window.addEventListener('error', (event) => {
    if (event.error && event.error.message && event.error.message.includes('privacy')) {
        console.error('‚ùå Privacy Guard Ïò§Î•ò:', event.error);
    }
});